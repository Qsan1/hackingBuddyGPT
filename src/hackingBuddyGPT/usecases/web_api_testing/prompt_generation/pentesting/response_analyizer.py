import json
import re

from hackingBuddyGPT.usecases.web_api_testing.prompt_generation.prompt_information import PromptPurpose


import json
import re

class ResponseAnalyzer(object):
    def __init__(self, purpose=None):
        self.purpose = purpose

    def set_purpose(self, purpose):
        self.purpose = purpose

    def parse_http_response(self, raw_response):
        """
        Parse the raw HTTP response string into its components: status line, headers, and body.
        """
        # Split the response into parts
        header_body_split = raw_response.split("\r\n\r\n", 1)
        header_lines = header_body_split[0].split("\n")
        body = header_body_split[1] if len(header_body_split) > 1 else ""

        # Extract status line and headers
        status_line = header_lines[0].strip()
        headers = {key.strip(): value.strip() for key, value in (line.split(":", 1) for line in header_lines[1:] if ':' in line)}

        # Parse the status line
        match = re.match(r"HTTP/1\.1 (\d{3}) (.*)", status_line)
        status_code = int(match.group(1)) if match else None

        return status_code, headers, body

    def analyze_response(self, raw_response):
        # Parse the HTTP response
        status_code, headers, body = self.parse_http_response(raw_response)
        # Analyze the parsed response based on the set purpose
        return self.analyze_parsed_response(status_code, headers, body)

    def analyze_parsed_response(self, status_code, headers, body):
        analysis_methods = {
            PromptPurpose.AUTHENTICATION_AUTHORIZATION: self.analyze_authentication_authorization(status_code, headers, body),
            PromptPurpose.INPUT_VALIDATION: self.analyze_input_validation(status_code, headers, body),
        }
        return analysis_methods.get(self.purpose)

    def analyze_authentication_authorization(self, status_code, headers, body):
        analysis = {
            'status_code': status_code,
            'authentication_status': "Authenticated" if status_code == 200 else
                                      "Not Authenticated or Not Authorized" if status_code in [401, 403] else "Unknown",
            'auth_headers_present': any(header in headers for header in ['Authorization', 'Set-Cookie', 'WWW-Authenticate']),
            'rate_limiting': {
                'X-Ratelimit-Limit': headers.get('X-Ratelimit-Limit'),
                'X-Ratelimit-Remaining': headers.get('X-Ratelimit-Remaining'),
                'X-Ratelimit-Reset': headers.get('X-Ratelimit-Reset'),
            },
            'content_body': "Empty" if body.strip() == "" else body.strip(),
        }
        return analysis

    def analyze_input_validation(self, status_code, headers, body):
        analysis = {
            'status_code': status_code,
            'response_body': "Empty" if body.strip() == "" else body.strip(),
            'is_valid_response': self.is_valid_input_response(status_code, body),
            'security_headers_present': any(key in headers for key in ["X-Content-Type-Options", "X-Ratelimit-Limit"]),
        }
        return analysis

    def is_valid_input_response(self, status_code, body):
        if status_code == 200:
            return "Valid"  # Successful processing might indicate lack of validation
        elif status_code == 400:
            return "Invalid"  # Expected for many invalid inputs
        elif status_code in [401, 403, 404, 500]:
            return "Error"  # Different errors based on the scenario
        else:
            return "Unexpected"

    def document_findings(self, status_code, headers, body, expected_behavior, actual_behavior):
        document = {
            "Status Code": status_code,
            "Headers": headers,
            "Response Body": body.strip(),
            "Expected Behavior": expected_behavior,
            "Actual Behavior": actual_behavior,
        }
        print("Documenting Findings:")
        print(json.dumps(document, indent=4))
        print("-" * 50)
        return document

    def report_issues(self, document):
        print("Reporting Issues:")
        if document["Expected Behavior"] != document["Actual Behavior"]:
            print("Issue Found:")
            print(f"Expected: {document['Expected Behavior']}")
            print(f"Actual: {document['Actual Behavior']}")
            print("Suggestion: Improve input validation, clearer error messages, or enhanced security measures.")
        else:
            print("No issues found in this test case.")
        print("-" * 50)

    def print_analysis(self, analysis):
        fields_to_print = {
            "HTTP Status Code": analysis.get("status_code"),
            "Response Body": analysis.get("response_body"),
            "Content Body": analysis.get("content_body"),
            "Valid Response": analysis.get("is_valid_response"),
            "Authentication Status": analysis.get("authentication_status"),
            "Security Headers Present": "Yes" if analysis.get("security_headers_present") else "No",
        }

        for label, value in fields_to_print.items():
            if value is not None:
                print(f"{label}: {value}")

        if "rate_limiting" in analysis:
            print("Rate Limiting Information:")
            for key, value in analysis["rate_limiting"].items():
                print(f"  {key}: {value}")

        print("-" * 50)


if __name__ == '__main__':
    # Example HTTP response to parse
    raw_http_response = """HTTP/1.1 404 Not Found
    Date: Fri, 16 Aug 2024 10:01:19 GMT
    Content-Type: application/json; charset=utf-8
    Content-Length: 2
    Connection: keep-alive
    Report-To: {"group":"heroku-nel","max_age":3600,"endpoints":[{"url":"https://nel.heroku.com/reports?ts=1723802269&sid=e11707d5-02a7-43ef-b45e-2cf4d2036f7d&s=dkvm744qehjJmab8kgf%2BGuZA8g%2FCCIkfoYc1UdYuZMc%3D"}]}
    Reporting-Endpoints: heroku-nel=https://nel.heroku.com/reports?ts=1723802269&sid=e11707d5-02a7-43ef-b45e-2cf4d2036f7d&s=dkvm744qehjJmab8kgf%2BGuZA8g%2FCCIkfoYc1UdYuZMc%3D
    Nel: {"report_to":"heroku-nel","max_age":3600,"success_fraction":0.005,"failure_fraction":0.05,"response_headers":["Via"]}
    X-Powered-By: Express
    X-Ratelimit-Limit: 1000
    X-Ratelimit-Remaining: 999
    X-Ratelimit-Reset: 1723802321
    Vary: Origin, Accept-Encoding
    Access-Control-Allow-Credentials: true
    Cache-Control: max-age=43200
    Pragma: no-cache
    Expires: -1
    X-Content-Type-Options: nosniff
    Etag: W/"2-vyGp6PvFo4RvsFtPoIWeCReyIC8"
    Via: 1.1 vegur
    CF-Cache-Status: HIT
    Age: 210
    Server: cloudflare
    CF-RAY: 8b40951728d9c289-VIE
    alt-svc: h3=":443"; ma=86400

    {}"""
    respons_analyzer = ResponseAnalyzer()
    respons_analyzer.purpose = PromptPurpose.AUTHENTICATION_AUTHORIZATION
    # Parse and analyze the HTTP response
    analysis = respons_analyzer.analyze_response(raw_http_response)

    # Print the analysis results
    respons_analyzer.print_analysis(analysis)
    respons_analyzer = ResponseAnalyzer()
    respons_analyzer.purpose = PromptPurpose.INPUT_VALIDATION
    # Parse and analyze the HTTP response
    analysis = respons_analyzer.analyze_response(raw_http_response)

    # Print the analysis results
    respons_analyzer.print_analysis(analysis)
